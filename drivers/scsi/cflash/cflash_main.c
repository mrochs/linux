/*
* Copyright 2015 IBM Corp.
*
* This program is free software; you can redistribute it and/or
* modify it under the terms of the GNU General Public License
* as published by the Free Software Foundation; either version
* 2 of the License, or (at your option) any later version.
*/
#include <linux/pci.h>
#include <linux/module.h>
#include <linux/mutex.h>
#include <linux/semaphore.h>
#include <linux/fs.h>
#include <linux/cdev.h>
#include <linux/libata.h>
#include <linux/reboot.h>

#include <misc/cxl.h>
#include <uapi/misc/cxl.h>

#include <scsi/scsi.h>
#include <scsi/scsi_host.h>
#include <scsi/scsi_device.h>
#include <scsi/scsi_tcq.h>
#include <scsi/scsi_eh.h>
#include <scsi/scsi_cmnd.h>
#include <scsi/scsi_transport_fc.h>

#include "cflash.h"
#include "cflash.h"
#include "sislite.h"
#include "cflash_mc.h"
#include "cflash_ba.h"
#include "cflash_ioctl.h"
#include "mserv.h"

MODULE_DESCRIPTION("IBM CAPI Flash Adapter Driver");
MODULE_AUTHOR("Manoj N. Kumar <kumarmn@us.ibm.com>");
MODULE_AUTHOR("Matthew R. Ochs <mrochs@us.ibm.com>");
MODULE_LICENSE("GPL");

extern void cflash_send_scsi(afu_t *, struct scsi_cmnd *);

unsigned int cflash_debug = 0;

/**
 * cflash_driver_info - Get information about the card/driver
 * @scsi_host:       scsi host struct
 *
 * Return value:
 *      pointer to buffer with description string
 **/
static const char *cflash_driver_info(struct Scsi_Host *host)
{
        static char buffer[512];
        unsigned long lock_flags = 0;

        spin_lock_irqsave(host->host_lock, lock_flags);
        sprintf(buffer, "IBM CAPI Flash Storage Adapter");
        spin_unlock_irqrestore(host->host_lock, lock_flags);

        return buffer;
}

/**
 * cflash_queuecommand_lck - Queue a mid-layer request
 * @shost:               scsi host struct
 * @scsi_cmd:            scsi command struct
 *
 * This function queues a request generated by the mid-layer.
 *
 * Return value:
 *      0 on success
 *      SCSI_MLQUEUE_DEVICE_BUSY if device is busy
 *      SCSI_MLQUEUE_HOST_BUSY if host is busy
 **/
static int cflash_queuecommand_lck(struct scsi_cmnd *scp,
				   void (*done)(struct scsi_cmnd *))
{
	struct Scsi_Host *host = scp->device->host;
	cflash_t *p_cflash     = (cflash_t *)host->hostdata;
        afu_t    *p_afu        = &p_cflash->p_afu_a->afu;

	/* XXX: Until the scsi_dma_map works, this stuff is meaningless
	 * Make the queuecommand entry point a dummy one for now.
	 */
	scp->scsi_done = done;
	scp->scsi_done(scp);
	return 0;
        cflash_info("in %s (scp=%p) %d/%d/%d/%llu " 
		    "cdb=(%08x-%08x-%08x-%08x)\n", 
		    __func__, scp, 
		    host->host_no, scp->device->channel, 
		    scp->device->id, scp->device->lun, 
		    cpu_to_be32(((u32 *)scp->cmnd)[0]), 
		    cpu_to_be32(((u32 *)scp->cmnd)[1]), 
		    cpu_to_be32(((u32 *)scp->cmnd)[2]), 
		    cpu_to_be32(((u32 *)scp->cmnd)[3]));

	scp->scsi_done = done;
	scp->result = (DID_OK << 16);;
	cflash_send_scsi(p_afu, scp);
        return 0;
}

static DEF_SCSI_QCMD(cflash_queuecommand)

/**
 * cflash_eh_abort_handler - Abort a single op
 * @scsi_cmd:                scsi command struct
 *
 * Return value:
 *      SUCCESS / FAILED
 **/
static int cflash_eh_abort_handler(struct scsi_cmnd *scsi_cmd)
{
        int rc = FAILED;

        ENTER;
	/* XXX: Dummy */
        LEAVE;
        cflash_info("in %s returning rc=%d\n", __func__, rc);
        return rc;
}

/**
 * cflash_eh_device_reset_handler - Reset a single LUN
 * @cmd:        scsi command struct
 *
 * Returns:
 *      SUCCESS / FAST_IO_FAIL / FAILED
 **/
static int cflash_eh_device_reset_handler(struct scsi_cmnd *cmd)
{
        int rc = FAILED;
	/* XXX: Dummy */
        cflash_info("in %s returning rc=%d\n", __func__, rc);
        return rc;
}


/**
 * cflash_eh_target_reset_handler - Reset the target
 * @cmd:        scsi command struct
 *
 * Returns:
 *      SUCCESS / FAST_IO_FAIL / FAILED
 **/
static int cflash_eh_target_reset_handler(struct scsi_cmnd *cmd)
{
        int rc = FAILED;
	/* XXX: Dummy */
        cflash_info("in %s returning rc=%d\n", __func__, rc);
        return rc;
}

/**
 * cflash_eh_host_reset_handler - Reset the connection to the server
 * @cmd:        struct scsi_cmnd having problems
 *
 **/
static int cflash_eh_host_reset_handler(struct scsi_cmnd *cmd)
{
        int rc = SUCCESS;
	/* XXX: Dummy */
        return rc;
}

/**
 * cflash_slave_alloc - Setup the device's task set value
 * @sdev:       struct scsi_device device to configure
 *
 * Set the device's task set value so that error handling works as
 * expected.
 *
 * Returns:
 *      0 on success / -ENXIO if device does not exist
 **/
static int cflash_slave_alloc(struct scsi_device *sdev)
{
	lun_info_t *p_luninfo;
	struct Scsi_Host *shost = sdev->host;
	cflash_t *p_cflash = shost_priv(shost);
        afu_t      *p_afu     = &p_cflash->p_afu_a->afu;
        int rc = 0;

	p_luninfo = &p_afu->lun_info[p_cflash->task_set];
	sdev->hostdata = p_luninfo;
	p_cflash->task_set++;

        cflash_info("in %s returning task_set %d luninfo %p sdev %p\n", 
		    __func__, p_cflash->task_set, p_luninfo, sdev);
	return rc;
}

/**
 * cflash_slave_configure - Configure the device
 * @sdev:       struct scsi_device device to configure
 *
 * Enable allow_restart for a device if it is a disk. Adjust the
 * queue_depth here also.
 *
 * Returns:
 *      0
 **/
static int cflash_slave_configure(struct scsi_device *sdev)
{
	/* XXX: Dummy */
	int rc=0;
        cflash_info("in %s returning rc=%d\n", __func__, rc);
	return 0;
}

/**
 * cflash_target_alloc - Setup the target's task set value
 * @starget:    struct scsi_target
 *
 * Set the target's task set value so that error handling works as
 * expected.
 *
 * Returns:
 *      0 on success / -ENXIO if device does not exist
 **/
static int cflash_target_alloc(struct scsi_target *starget)
{
	/* XXX: Dummy */
	int rc=0;
	struct Scsi_Host *shost = dev_to_shost(starget->dev.parent);
	cflash_t *p_cflash = shost_priv(shost);

        cflash_info("in %s returning rc=%d ts%d\n", __func__, rc, p_cflash->task_set);
        return 0;
}

/**
 * cflash_scan_finished - Check if the device scan is done.
 * @shost:      scsi host struct
 * @time:       current elapsed time
 *
 * Returns:
 *      0 if scan is not done / 1 if scan is done
 **/
static int cflash_scan_finished(struct Scsi_Host *shost, unsigned long time)
{
        int done = 1;
	/* XXX: Dummy */
        cflash_info("in %s returning done=%d\n", __func__, done);
        return done;
}

/**
 * cflash_change_queue_depth - Change the device's queue depth
 * @sdev:       scsi device struct
 * @qdepth:     depth to set
 * @reason:     calling context
 *
 * Return value:
 *      actual depth set
 **/
static int cflash_change_queue_depth(struct scsi_device *sdev, int qdepth,
                                     int reason)
{
        if (reason != SCSI_QDEPTH_DEFAULT)
                return -EOPNOTSUPP;

        if (qdepth > CFLASH_MAX_CMDS_PER_LUN)
                qdepth = CFLASH_MAX_CMDS_PER_LUN;

        scsi_adjust_queue_depth(sdev, 0, qdepth);
        return sdev->queue_depth;
}

/**
 * cflash_change_queue_type - Change the device's queue type
 * @sdev:               scsi device struct
 * @tag_type:   type of tags to use
 *
 * Return value:
 *      actual queue type set
 **/
static int cflash_change_queue_type(struct scsi_device *sdev, int tag_type)
{
        if (sdev->tagged_supported) {
                scsi_set_tag_type(sdev, tag_type);

                if (tag_type)
                        scsi_activate_tcq(sdev, sdev->queue_depth);
                else
                        scsi_deactivate_tcq(sdev, sdev->queue_depth);
        } else
                tag_type = 0;

        return tag_type;
}


static ssize_t cflash_show_host_partition_name(struct device *dev,
					       struct device_attribute *attr,
					       char *buf)
{

	/* XXX: Dummy */

        return 0;
}

static ssize_t cflash_show_host_device_name(struct device *dev,
                                            struct device_attribute *attr,
					    char *buf)
{

	/* XXX: Dummy */

        return 0;
}

static ssize_t cflash_show_host_loc_code(struct device *dev,
                                         struct device_attribute *attr,
					 char *buf)
{
	/* XXX: Dummy */

        return 0;
}

static ssize_t cflash_show_host_drc_name(struct device *dev,
                                         struct device_attribute *attr,
					 char *buf)
{
	/* XXX: Dummy */

        return 0;
}

static ssize_t cflash_show_host_npiv_version(struct device *dev,
                                             struct device_attribute *attr,
					     char *buf)
{
	/* XXX: Dummy */

        return 0;
}

static ssize_t cflash_show_host_capabilities(struct device *dev,
                                             struct device_attribute *attr,
					     char *buf)
{
	/* XXX: Dummy */

        return 0;
}

/**
 * cflash_show_log_level - Show the adapter's error logging level
 * @dev:        class device struct
 * @buf:        buffer
 *
 * Return value:
 *      number of bytes printed to buffer
 **/
static ssize_t cflash_show_log_level(struct device *dev,
                                     struct device_attribute *attr, char *buf)
{
	/* XXX: Dummy */

        return 0;
}

/**
 * cflash_store_log_level - Change the adapter's error logging level
 * @dev:        class device struct
 * @buf:        buffer
 *
 * Return value:
 *      number of bytes printed to buffer
 **/
static ssize_t cflash_store_log_level(struct device *dev,
                                      struct device_attribute *attr,
                                      const char *buf, size_t count)
{
	/* XXX: Dummy */

        return 0;
}

/**
 * cflash_wait_for_pci_err_recovery - Wait for any PCI error recovery to
 *					complete during probe time
 * @p_cflash:    cflash config struct
 * 
 * Return value:
 *	None
 */
static void cflash_wait_for_pci_err_recovery(cflash_t *p_cflash)
{
	struct pci_dev *pdev = p_cflash->p_dev;

	if (pci_channel_offline(pdev)) {
		wait_event_timeout(p_cflash->eeh_wait_q, 
				   !pci_channel_offline(pdev),
				   CFLASH_PCI_ERROR_RECOVERY_TIMEOUT);
		pci_restore_state(pdev);
	}
}

/**
 * cflash_ioctl - IOCTL handler
 * @sdev:       scsi device struct
 * @cmd:        IOCTL cmd
 * @arg:        IOCTL arg
 *
 * Return value:
 *      0 on success / other on failure
 **/
static int cflash_ioctl(struct scsi_device *sdev, int cmd, void __user *arg)
{
	cflash_t *p_cflash;
	int	  rc;

	p_cflash = (cflash_t *)sdev->hostdata;

	switch (cmd) {
	case DK_CAPI_ATTACH:
		rc = cflash_disk_attach(sdev, arg);
		if (rc) {
			goto cflash_ioctl_exit;
		}

		break;
	case DK_CAPI_USER_DIRECT:
	case DK_CAPI_USER_VIRTUAL:
		rc = cflash_disk_uvirtual(sdev, arg);
		if (rc) {
			goto cflash_ioctl_exit;
		}

		break;
	case DK_CAPI_DETACH:
		rc = cflash_disk_detach(sdev, arg);
		if (rc) {
			goto cflash_ioctl_exit;
		}

		break;
	case DK_CAPI_VLUN_RESIZE:
		rc = cflash_vlun_resize(sdev, arg);
		if (rc) {
			goto cflash_ioctl_exit;
		}

		break;
	case DK_CAPI_RELEASE:
		rc = cflash_disk_release(sdev, arg);
		if (rc) {
			goto cflash_ioctl_exit;
		}

		break;
	default:
		/* XXX - TODO: MRO - do we pass along to another handler (ie:
		 * ata_sas_scsi_ioctl() a la ipr.c) ?
		 */
		rc = -EINVAL;
		break;
	}

cflash_ioctl_exit:
	cflash_info("ioctl 0x%x returned rc %d\n", cmd, rc);
	return rc;
}

/* XXX - These are examples of attributes that will be pushed/populated in
 * sysfs, the last argument is the callback. We can use cflash_store_log_level
 * as an example. There is also a 'sdev_attrs' member of the scsi_host_template
 * structure. I'm thinking that might be more appropriate for us, at least for
 * the MC communications path.
 */
static DEVICE_ATTR(partition_name, S_IRUGO, cflash_show_host_partition_name, 
		   NULL);
static DEVICE_ATTR(device_name, S_IRUGO, cflash_show_host_device_name, NULL);
static DEVICE_ATTR(port_loc_code, S_IRUGO, cflash_show_host_loc_code, NULL);
static DEVICE_ATTR(drc_name, S_IRUGO, cflash_show_host_drc_name, NULL);
static DEVICE_ATTR(npiv_version, S_IRUGO, cflash_show_host_npiv_version, NULL);
static DEVICE_ATTR(capabilities, S_IRUGO, cflash_show_host_capabilities, NULL);
static DEVICE_ATTR(log_level, S_IRUGO | S_IWUSR,
                   cflash_show_log_level, cflash_store_log_level);

static struct device_attribute *cflash_attrs[] = {
        &dev_attr_partition_name,
        &dev_attr_device_name,
        &dev_attr_port_loc_code,
        &dev_attr_drc_name,
        &dev_attr_npiv_version,
        &dev_attr_capabilities,
        &dev_attr_log_level,
        NULL
};


static struct scsi_host_template driver_template = {
        .module = THIS_MODULE,
        .name = "IBM POWER CAPI Flash Adapter",
        .info = cflash_driver_info,
	.ioctl = cflash_ioctl,
        .proc_name = CFLASH_NAME,
        .queuecommand = cflash_queuecommand,
        .eh_abort_handler = cflash_eh_abort_handler,
        .eh_device_reset_handler = cflash_eh_device_reset_handler,
        .eh_target_reset_handler = cflash_eh_target_reset_handler,
        .eh_host_reset_handler = cflash_eh_host_reset_handler,
        .slave_alloc = cflash_slave_alloc,
        .slave_configure = cflash_slave_configure,
        .target_alloc = cflash_target_alloc,
        .scan_finished = cflash_scan_finished,
        .change_queue_depth = cflash_change_queue_depth,
        .change_queue_type = cflash_change_queue_type,
        .cmd_per_lun = 16,
        .can_queue = CFLASH_MAX_REQUESTS_DEFAULT,
        .this_id = -1,
        .sg_tablesize = SG_NONE, /* No scatter gather support. */
        .max_sectors = CFLASH_MAX_SECTORS,
        .use_clustering = ENABLE_CLUSTERING,
        .shost_attrs = cflash_attrs,
};

static struct pci_device_id cflash_pci_table[] = {
	{ PCI_DEVICE(PCI_VENDOR_ID_IBM, PCI_DEVICE_ID_IBM_CORSA), },
        {}
};


/**
 * cflash_free_mem - Frees memory allocated for an adapter
 * @ioa_cfg:    ioa cfg struct
 *
 * Return value:
 *      nothing
 **/
static void cflash_free_mem(cflash_t *p_cflash)
{
	/* XXX: Dummy */
	return;
}

/**
 * cflash_remove - CFLASH hot plug remove entry point
 * @pdev:       pci device struct
 *
 * Adapter hot plug remove entry point.
 *
 * Return value:
 *      none
 **/
static void cflash_remove(struct pci_dev *pdev)
{
        cflash_t *p_cflash = pci_get_drvdata(pdev);
        ENTER;

        dev_err(&pdev->dev, "enter cflash_remove!\n");

	cflash_term_afu(p_cflash);
        dev_err(&pdev->dev, "after cflash_term_afu!\n");

        scsi_remove_host(p_cflash->host);
        dev_err(&pdev->dev, "after scsi_remove_host!\n");

	/* XXX: Commented out for now 
	iounmap(p_cflash->cflash_regs);
	pci_release_regions(p_cflash->p_dev); 
	*/

	cflash_free_mem(p_cflash); 
	scsi_host_put(p_cflash->host); 
        dev_err(&pdev->dev, "after scsi_host_put!\n");

	/* XXX: Commented out for now
	pci_disable_device(pdev);
	*/

        LEAVE;
}


static int cflash_gb_alloc(cflash_t *p_cflash)
{
	int nbytes;
	int rc=0;

	nbytes = sizeof(struct afu_alloc) * CFLASH_NAFU;
	p_cflash->p_afu_a = (void *)__get_free_pages(GFP_KERNEL | __GFP_ZERO, 
						     get_order(nbytes));
	if (!p_cflash->p_afu_a) {
		cflash_err("cannot get %d free pages\n", get_order(nbytes));
		rc = -ENOMEM;
		goto out;
	}

out:
    return rc;
}

static int cflash_init_pci(cflash_t *p_cflash)
{
	struct pci_dev *pdev = p_cflash->p_dev;
	int	rc = 0;

	p_cflash->cflash_regs_pci = pci_resource_start(pdev, 0);
	rc = pci_request_regions(pdev, CFLASH_NAME);
	if (rc < 0) {
		dev_err(&pdev->dev,
			"Couldn't register memory range of registers\n");
		 goto out;
	}

	/* XXX: Ignore errors until Mikey's fix comes in.
	rc = pci_enable_device(pdev);
	*/
	pci_enable_device(pdev);

	if (rc || pci_channel_offline(pdev)) {
		if (pci_channel_offline(pdev)) {
			cflash_wait_for_pci_err_recovery(p_cflash);
			rc = pci_enable_device(pdev);
		}

		if (rc) {
			dev_err(&pdev->dev, "Cannot enable adapter\n");
			cflash_wait_for_pci_err_recovery(p_cflash);
			goto out_release_regions;
		}
	}

	/*
	p_cflash->cflash_regs = pci_ioremap_bar(pdev, 0);

	if (!p_cflash->cflash_regs) {
		dev_err(&pdev->dev,
			"Couldn't map memory range of registers\n");
		rc = -ENOMEM;
		goto out_disable;
	} 
	*/
	
	rc = pci_set_dma_mask(pdev, DMA_BIT_MASK(64)); 
	if (rc < 0) { 
		dev_dbg(&pdev->dev, "Failed to set 64 bit PCI DMA mask\n"); 
		rc = pci_set_dma_mask(pdev, DMA_BIT_MASK(32)); 
	} 
	
	if (rc < 0) { 
		dev_err(&pdev->dev, "Failed to set PCI DMA mask\n");
	       	goto out_disable; 
	} 
	
	rc = pci_write_config_byte(pdev, PCI_CACHE_LINE_SIZE, 0x20);
	
	if (rc != PCIBIOS_SUCCESSFUL) { 
		dev_err(&pdev->dev, "Write of cache line size failed\n"); 
		cflash_wait_for_pci_err_recovery(p_cflash); 
		
		rc = -EIO;
										                goto out_disable; 
	} 

	pci_set_master(pdev);

	if (pci_channel_offline(pdev)) {
		 cflash_wait_for_pci_err_recovery(p_cflash);
		 pci_set_master(pdev);
		 if (pci_channel_offline(pdev)) {
			 rc = -EIO;
			 goto out_msi_disable;
		 }
	}

	/* Save away PCI config space for use following CFLASH reset */
	rc = pci_save_state(pdev);

	if (rc != PCIBIOS_SUCCESSFUL) {
		dev_err(&pdev->dev, "Failed to save PCI config space\n");
		rc = -EIO;
		goto cleanup_nolog;
	}
	
out:
	return rc;

cleanup_nolog:
	/* XXX: free up any resources allocated here.
	cflash_free_mem(p_cflash);
	*/
out_msi_disable:
	cflash_wait_for_pci_err_recovery(p_cflash);
	iounmap(p_cflash->cflash_regs);
out_disable:
	pci_disable_device(pdev);
out_release_regions:
	pci_release_regions(pdev);
	goto out;

}

/**
 * cflash_scan_vsets - Scans for VSET devices
 * @p_cflash:    cflash_t config struct
 *
 * Description: Since the VSET resources do not follow SAM in that we can have
 * sparse LUNs with no LUN 0, we have to scan for these ourselves.
 *
 * Return value:
 *      none
 **/
static void cflash_scan_vsets(cflash_t *p_cflash)
{
	int j, rc;

        for (j = 0; j < NUM_FC_PORTS; j++) { /* discover on each port */
		 if ((rc = find_lun(p_cflash, 1u << j)) == 0) {
			 cflash_info("Found valid lun on port=%d\n", j);
		 } else {
			 cflash_err("find_lun returned rc=%d\n", rc);
		 }
	}
}

int cflash_init_ba(cflash_t *p_cflash, int lunindex)
{
	afu_t      *p_afu     = &p_cflash->p_afu_a->afu;
	lun_info_t *p_luninfo = &p_afu->lun_info[lunindex];
	int rc = 0;
	blka_t *p_blka = NULL;

	p_blka = kzalloc(sizeof(*p_blka), GFP_KERNEL);
	if (!p_blka) {
		cflash_err("Failed to get memory for block alloc!\n");
		rc = -ENOMEM;
		goto cflash_init_ba_exit;
	}

	mutex_init(&p_blka->mutex);

	p_blka->ba_lun.lun_id	= p_luninfo->lun_id;
	p_blka->ba_lun.lsize	= p_luninfo->li.max_lba + 1;
	p_blka->ba_lun.lba_size	= p_luninfo->li.blk_len;

	p_blka->ba_lun.au_size	= MC_CHUNK_SIZE;
	p_blka->nchunk		= p_blka->ba_lun.lsize/MC_CHUNK_SIZE;

	rc = ba_init(&p_blka->ba_lun);
	if (rc) {
		cflash_err("cannot init block_alloc, rc %d\n", rc);
		goto cflash_init_ba_exit;
	}

	p_afu->p_blka[lunindex] = p_blka;

cflash_init_ba_exit:
	if (rc && p_blka)
		kfree(p_blka);

        cflash_info("in %s returning index %d p_blka %p rc=%d\n", 
		    __func__, lunindex, p_afu->p_blka[lunindex], rc);
	return(rc);
}

static int cflash_init_scsi(cflash_t *p_cflash)
{
	struct pci_dev *pdev = p_cflash->p_dev;
	int rc = 0;

	dev_info(&pdev->dev, "in %s before scsi_add_host\n", __func__);
	rc = scsi_add_host(p_cflash->host, &pdev->dev);
	if (rc) {
		cflash_remove(pdev);
		goto out;
	}

	dev_info(&pdev->dev, "in %s before scsi_scan_host\n", __func__);
	scsi_scan_host(p_cflash->host);

	cflash_scan_vsets(p_cflash);

	/*
	dev_info(&pdev->dev, "in %s before scsi_add_device\n", __func__);
	scsi_add_device(p_cflash->host, CFLASH_BUS, CFLASH_TARGET,
			CFLASH_LUN);
	*/

out:
	return rc;
}

/**
 * cflash_probe - Adapter hot plug add entry point
 *
 * Return value:
 *      0 on success / non-zero on failure
 **/
static int cflash_probe(struct pci_dev *pdev, 
			const struct pci_device_id *dev_id)
{
	struct Scsi_Host *host;
	cflash_t *p_cflash = NULL;
	struct device  *phys_dev;
	int	rc = 0;

        ENTER;

	dev_info(&pdev->dev, "Found CFLASH with IRQ: %d\n", pdev->irq);

	host = scsi_host_alloc(&driver_template, sizeof(cflash_t));

        if (!host) {
                dev_err(&pdev->dev, "call to scsi_host_alloc failed!\n");
                rc = -ENOMEM;
                goto out;
        }
	/* XXX: Need to double check with the sislite spec */
	host->max_id = CFLASH_MAX_NUM_TARGETS_PER_BUS;
	host->max_lun = CFLASH_MAX_NUM_VSET_LUNS_PER_TARGET;
	host->max_channel = CFLASH_BUS;
	host->unique_id = host->host_no;
	host->max_cmd_len = CFLASH_MAX_CDB_LEN;

        p_cflash = (cflash_t *)host->hostdata;
	p_cflash->host = host;
	rc = cflash_gb_alloc(p_cflash);
	if (rc)
	{
                dev_err(&pdev->dev, "call to scsi_host_alloc failed!\n");
                rc = -ENOMEM;
                goto out;
	}

	p_cflash->p_dev = pdev;
	p_cflash->last_lun_index = 0;
	p_cflash->task_set = 0;
	p_cflash->p_dev_id = (struct pci_device_id *)dev_id;
	pci_set_drvdata(pdev, p_cflash);

#ifdef NEWCXL
	/* XXX: How to adderess both the AFUs on the CORSA */
	p_cflash->afu = cxl_pci_to_afu(pdev, NULL);
	cflash_init_afu(p_cflash);

	/* XXX: Add threads for afu_rrq_rx and afu_err_rx */
	/* after creating afu_err_rx thread, unmask error interrupts */
	afu_err_intr_init(&p_cflash->p_afu_a->afu);

#endif /* NEWCXL */

	/* XXX: Commented out for now, until Mikey's implementation is done 
	rc = cflash_init_pci(p_cflash);
	cflash_init_pci(p_cflash);
	if (rc) {
                dev_err(&pdev->dev, "call to cflash_init_pci failed rc=%d!\n",
			rc);
		goto out_remove;
	}
	*/

	/* Use the special service provided to look up the physical
         * PCI device, since we are called on the probe of the virtual
         * PCI host bus (vphb)
         */
	phys_dev = cxl_get_phys_dev(pdev);
	if (!dev_is_pci(phys_dev)) { /* make sure it's pci */
		printk("not a pci dev\n");
		rc = ENODEV;
		goto out_remove;
	}
	p_cflash->parent_dev = to_pci_dev(phys_dev);

	rc = cflash_init_scsi(p_cflash);
	if (rc) {
                dev_err(&pdev->dev, "call to cflash_init_scsi failed rc=%d!\n",
			rc);
		goto out_remove;
	}

        LEAVE;
out:
	return rc;

out_remove:
	cflash_remove(pdev);
        scsi_host_put(host);
        goto out;
}

/**
 * cflash_shutdown - Shutdown handler.
 * @pdev:       pci device struct
 *
 * This function is invoked upon system shutdown/reboot. It will issue
 * an adapter shutdown to the adapter to flush the write cache.
 *
 * Return value:
 *      none
 **/
static void cflash_shutdown(struct pci_dev *pdev)
{
	/* XXX: Dummy */
}


/**
 * cflash_pci_error_detected - Called when a PCI error is detected.
 * @pdev:       PCI device struct
 * @state:      PCI channel state
 *
 * Description: Called when a PCI error is detected.
 *
 * Return value:
 *      PCI_ERS_RESULT_NEED_RESET or PCI_ERS_RESULT_DISCONNECT
 */
static pci_ers_result_t cflash_pci_error_detected(struct pci_dev *pdev,
                                               pci_channel_state_t state)
{
        switch (state) {
        case pci_channel_io_frozen:
		/* XXX: Dummy */
                return PCI_ERS_RESULT_CAN_RECOVER;
        case pci_channel_io_perm_failure:
		/* XXX: Dummy */
                return PCI_ERS_RESULT_DISCONNECT;
                break;
        default:
                break;
        }
        return PCI_ERS_RESULT_NEED_RESET;
}


/**
 * cflash_pci_mmio_enabled - Called when MMIO has been re-enabled
 * @pdev:       PCI device struct
 *
 * Description: This routine is called to tell us that the MMIO
 * access to the CFLASH has been restored
 */
static pci_ers_result_t cflash_pci_mmio_enabled(struct pci_dev *pdev)
{
	/* XXX: Dummy */
        return PCI_ERS_RESULT_NEED_RESET;
}

/**
 * cflash_pci_slot_reset - Called when PCI slot has been reset.
 * @pdev:       PCI device struct
 *
 * Description: This routine is called by the pci error recovery
 * code after the PCI slot has been reset, just before we
 * should resume normal operations.
 */
static pci_ers_result_t cflash_pci_slot_reset(struct pci_dev *pdev)
{
	/* XXX: Dummy */
        return PCI_ERS_RESULT_RECOVERED;
}

static const struct pci_error_handlers cflash_err_handler = {
        .error_detected = cflash_pci_error_detected,
        .mmio_enabled = cflash_pci_mmio_enabled,
        .slot_reset = cflash_pci_slot_reset,
};

static struct pci_driver cflash_driver = {
        .name = CFLASH_NAME,
        .id_table = cflash_pci_table,
        .probe = cflash_probe,
        .remove = cflash_remove,
        .shutdown = cflash_shutdown,
        .err_handler = &cflash_err_handler,
};


/**
 * cflash_halt - Issue shutdown prepare to all adapters
 *
 * Return value:
 *      NOTIFY_OK on success / NOTIFY_DONE on failure
 **/
static int cflash_halt(struct notifier_block *nb, ulong event, void *buf)
{
	/* XXX: Dummy */
	return NOTIFY_OK;
}

static struct notifier_block cflash_notifier = {
        cflash_halt, NULL, 0
};

static int __init init_cflash(void)
{
        cflash_info("IBM Power CAPI Flash Adapter version: %s %s\n",
                 CFLASH_DRIVER_VERSION, CFLASH_DRIVER_DATE);

        register_reboot_notifier(&cflash_notifier);
        return pci_register_driver(&cflash_driver);
}

static void exit_cflash(void)
{
        unregister_reboot_notifier(&cflash_notifier);
        pci_unregister_driver(&cflash_driver);
}

module_init(init_cflash);
module_exit(exit_cflash);

